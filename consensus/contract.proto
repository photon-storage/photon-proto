syntax = "proto3";

package photon.consensus;

import "ext/options.proto";

option csharp_namespace = "photon.proto.consensus";
option go_package = "github.com/photon-storage/photon-proto/consensus;pbc";
option java_multiple_files = true;
option java_outer_classname = "ContractProto";
option java_package = "storage.photon.proto.consensus";
option php_namespace = "photon\\proto\\consensus";

// Storage contract status enum.
enum StorageStatus {
    // INVALID prevents from defaulting to a valid status.
    STORAGE_INVALID = 0;
    // CREATED indicates a newly created storage contract.
    CREATED = 1;
    // OPEN indicates a valid and effective storage contract.
    OPEN = 2;
    // AUDIT indicates an object audit is required.
    AUDIT = 3;
}

// StorageContract defines a storage contract between an account and
// a storoage provider.
message StorageContract {
    // The root hash of the original commit transaction associated with this
    // storage contract.
    bytes commit_tx_hash = 1 [(photon.ext.ssz_size) = "32"];

    // The Merkle tree root hash of the stored original data.
    bytes object_hash = 2 [(photon.ext.ssz_size) = "32"];

    // The size of the stored original data.
    uint64 size = 3;

    // The public key of the data owner.
    bytes owner = 4 [(photon.ext.ssz_size) = "48"];

    // The public key of the storage provider.
    bytes depot = 5 [(photon.ext.ssz_size) = "48"];

    // The p2p network discovery ID used for finding depot RPC endpoint.
    bytes depot_discovery_id = 6 [(photon.ext.ssz_size) = "32"];

    // The effective slot of the storage contract.
    uint64 start = 7 [(photon.ext.cast_type) = "Slot"];

    // Expiring slot of the storage contract.
    // The contract expires **after** the end slot.
    uint64 end = 8 [(photon.ext.cast_type) = "Slot"];

    // Total storage fee that data owner paid.
    uint64 fee = 9;

    // Storage providers collateral deposit.
    uint64 bond = 10;

    // Status defines status of contract. Equivalent to StorageStatus. Use
    // uint32 because SSZ does not support proto enum type.
    uint32 status = 11;

    // End slot of the status.
    uint64 status_expiration = 12 [(photon.ext.cast_type) = "Slot"];

    // The public key of the selected auditor.
    bytes auditor = 13 [(photon.ext.ssz_size) = "48"];

    // Audit hash of the Audit struct if non-empty.
    bytes audit_hash = 14 [(photon.ext.ssz_size) = "32"];

    // PoR hash of the PoR struct if non-empty.
    bytes por_hash = 15 [(photon.ext.ssz_size) = "32"];
}

// Audit defines information for encoded object data generated by audit.
message Audit {
    // Hash of encoded data generated by audit.
    bytes encoded_hash = 1 [(photon.ext.ssz_size) = "32"];

    // Size of encoded data generated by audit.
    uint64 encoded_size = 2;

    // Number of blocks of encoded data.
    uint32 num_blocks = 3;

    // NOTE(kmax): hash of block signatures?

    // An array of random elements used to generated block signature.
    // The count is equal to sectors_per_block.
    repeated bytes rands = 4 [(photon.ext.ssz_max) = "64,96"];
}

message Challenge {
    // Block index challenged.
    uint32 block_index = 1;

    // Coefficient for the block challenge.
    bytes coefficient = 2 [(photon.ext.ssz_size) = "32"];
}

message PoR {
    // PoR start slot.
    uint64 start = 1 [(photon.ext.cast_type) = "Slot"];

    // The Merkle tree root hash of the stored original data.
    bytes object_hash = 2 [(photon.ext.ssz_size) = "32"];

    // Audit hash used to retrieve the particular version of audit when the
    // PoR is initiated.
    bytes audit_hash = 3 [(photon.ext.ssz_size) = "32"];

    // The public key of the last auditor.
    bytes auditor = 4 [(photon.ext.ssz_size) = "48"];

    // PoR challenges.
    repeated Challenge challenges = 5 [(photon.ext.ssz_max) = "32"];
}

message EpochStorageEvent {
    repeated StorageEvent events = 1;
}

message StorageEvent {
    // Event type.
    StorageEventType type = 1;

    // The root hash of the transaction (storage contract) associated with
    // this event.
    bytes tx_hash = 2 [(photon.ext.ssz_size) = "32"];

    // The public key of the depot specified in the storage contract.
    bytes depot = 3 [(photon.ext.ssz_size) = "48"];

    // The public key of the auditor assigned for auditing task.
    bytes auditor = 4 [(photon.ext.ssz_size) = "48"];
}

// Storage contract event type.
enum StorageEventType {
    // INVALID prevents from defaulting to a valid status.
    STORAGE_EVENT_TYPE_INVALID = 0;
    // AUDIT_NEW is an object audit start event.
    AUDIT_NEW = 1;
    // POR_NEW is an object PoR start event.
    POR_NEW = 2;
    // AUDIT_EXPIRATION is an object audit window expiration event.
    AUDIT_EXPIRATION = 3;
    // CONTRACT_EXPIRATION is a storage contract expiration event.
    CONTRACT_EXPIRATION = 4;
}


// Request for a storage contract of the given tx hash.
message GetStorageContractRequest{
    // Tx hash of the storage contract to be requested.
    bytes tx_hash = 1 [(photon.ext.ssz_size) = "32"];
}

// Response for the GetStorageContractRequest.
message GetStorageContractResponse {
    StorageContract contract = 1;
}
