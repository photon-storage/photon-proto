syntax = "proto3";

package photon.consensus;

import "ext/options.proto";

option csharp_namespace = "photon.proto.consensus";
option go_package = "github.com/photon-storage/photon-proto/consensus;pbc";
option java_multiple_files = true;
option java_outer_classname = "ContractProto";
option java_package = "storage.photon.proto.consensus";
option php_namespace = "photon\\proto\\consensus";

// Storage contract status enum.
enum StorageStatus {
    // INVALID prevents from defaulting to a valid status.
    STORAGE_INVALID = 0;
    // CREATED indicates a newly created storage contract.
    CREATED = 1;
    // OPEN indicates a valid and effective storage contract.
    OPEN = 2;
    // AUDIT indicates an object audit is required.
    AUDIT = 3;
    // PAUSED indicates an object has missed an audit assignment and
    // is waiting for the next audit assignment.
    PAUSED = 4;
    // ZOMBIE indicates zombie storage contract (not effective) due to
    // reasons such as depleted pledge, etc.
    ZOMBIE = 5;
}

// StorageContract defines a storage contract between an account and
// a storoage provider.
message StorageContract {
    // The root hash of the original commit transaction associated with this
    // storage contract.
    bytes commit_tx_hash = 1 [(photon.ext.ssz_size) = "32"];

    // The Merkle tree root hash of the stored original data.
    bytes object_hash = 2 [(photon.ext.ssz_size) = "32"];

    // The size of the stored original data.
    uint64 size = 3;

    // The public key of the data owner.
    bytes owner = 4 [(photon.ext.ssz_size) = "48"];

    // The public key of the storage provider.
    bytes depot = 5 [(photon.ext.ssz_size) = "48"];

    // The p2p network discovery ID used for finding depot RPC endpoint.
    bytes depot_discovery_id = 6 [(photon.ext.ssz_size) = "32"];

    // The effective slot of the storage contract.
    uint64 start = 7 [(photon.ext.cast_type) = "Slot"];

    // Expiring slot of the storage contract.
    // The contract expires **after** the end slot.
    uint64 end = 8 [(photon.ext.cast_type) = "Slot"];

    // Total storage fee that data owner paid.
    uint64 fee = 9;

    // Storage providers collateral deposit.
    uint64 pledge = 10;

    Mutable mutable = 11;

    // Fields that can be updated during the lifetime of a contract.
    // TODO(kmax): consider moving this struct into a separate trie to save space.
    message Mutable {
        // Status defines status of contract. Equivalent to StorageStatus. Use
        // uint32 because SSZ does not support proto enum type.
        uint32 status = 1;

        // Start slot of the status.
        uint64 status_start = 2 [(photon.ext.cast_type) = "Slot"];

        // End slot of the status.
        uint64 status_end = 3 [(photon.ext.cast_type) = "Slot"];

        // The public key of the selected auditor.
        bytes auditor = 4 [(photon.ext.ssz_size) = "48"];

        // Audit hash of the Audit struct if non-empty.
        bytes audit_hash = 5 [(photon.ext.ssz_size) = "32"];

        // Hash of the PoRChallenge struct if non-empty.
        bytes por_challenge_hash = 6 [(photon.ext.ssz_size) = "32"];

        // Remaining pledge.
        uint64 pledge_remaining = 7;
    }
}


// Storage contract event type used for scheduling event in event queue.
enum StorageEventType {
    // EVENT_INVALID prevents from defaulting to a valid status.
    EVENT_INVALID = 0;
    // AUDIT_EXPIRATION is an object audit window expiration event.
    AUDIT_EXPIRATION = 1;
    // POR_EXPIRATION is an object PoR window expiration event.
    POR_EXPIRATION = 2;
    // CONTRACT_EXPIRATION is a storage contract expiration event.
    CONTRACT_EXPIRATION = 3;
}

// Audit defines information for encoded object data generated by audit.
message Audit {
    // The public key of the auditor.
    bytes auditor = 1 [(photon.ext.ssz_size) = "48"];

    // Audit start slot.
    uint64 start = 2 [(photon.ext.cast_type) = "Slot"];

    // Hash of encoded data generated by audit.
    bytes encoded_hash = 3 [(photon.ext.ssz_size) = "32"];

    // Size of encoded data generated by audit.
    uint64 encoded_size = 4;

    // Number of blocks of encoded data.
    uint32 num_blocks = 5;

    // NOTE(kmax): hash of block signatures?

    // An array of random elements used to generated block signature.
    // The count is equal to sectors_per_block.
    repeated bytes rands = 6 [(photon.ext.ssz_max) = "64,96"];
}

message BlockPick {
    // Block index challenged.
    uint32 block_index = 1;

    // Coefficient for the block challenge.
    bytes coefficient = 2 [(photon.ext.ssz_size) = "32"];
}

message PoRChallenge {
     // The public key of the object PoR challenger.
    bytes challenger = 1 [(photon.ext.ssz_size) = "48"];

    // PoR start slot.
    uint64 start = 2 [(photon.ext.cast_type) = "Slot"];

    // PoR end/exipratioin slot.
    uint64 end = 3 [(photon.ext.cast_type) = "Slot"];

    // The Merkle tree root hash of the stored original data.
    bytes object_hash = 4 [(photon.ext.ssz_size) = "32"];

    // Audit hash used to retrieve the particular version of audit when the
    // PoR is initiated.
    bytes audit_hash = 5 [(photon.ext.ssz_size) = "32"];

    // The public key of the last auditor.
    bytes auditor = 6 [(photon.ext.ssz_size) = "48"];

    // Random block picks for the PoR challenge.
    repeated BlockPick picks = 7 [(photon.ext.ssz_max) = "32"];
}

// Request for a storage contract of the given tx hash.
message GetStorageContractRequest{
    // Tx hash of the storage contract to be requested.
    bytes commit_tx_hash = 1 [(photon.ext.ssz_size) = "32"];
}

// Response for the GetStorageContractRequest.
message GetStorageContractResponse {
    StorageContract contract = 1;
}

// Request for a PoR challenge targeted for a storage contract.
message GetPoRChallengeRequest{
    // Tx hash of the storage contract.
    bytes commit_tx_hash = 1 [(photon.ext.ssz_size) = "32"];
    // Hash of the corresponding PoRChallenge struct to request.
    bytes por_challenge_hash = 2 [(photon.ext.ssz_size) = "32"];
}

// Response for the GetPoRChallengeRequest.
message GetPoRChallengeResponse {
    PoRChallenge challenge = 1;
}
