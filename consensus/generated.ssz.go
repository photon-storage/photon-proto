// Code generated by fastssz. DO NOT EDIT.
// Hash: 2df776d62d92108ecba48b9df6151f0490d834d0acd08e4be08c778d702d70ea
package pbc

import (
	ssz "github.com/photon-storage/fastssz"
)

// MarshalSSZ ssz marshals the Account object
func (a *Account) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Account object to a target array
func (a *Account) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(68)

	// Field (0) 'PublicKey'
	if len(a.PublicKey) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.PublicKey...)

	// Field (1) 'Nonce'
	dst = ssz.MarshalUint64(dst, a.Nonce)

	// Field (2) 'Balance'
	dst = ssz.MarshalUint64(dst, a.Balance)

	// Offset (3) 'Storage'
	dst = ssz.WriteOffset(dst, offset)
	if a.Storage == nil {
		a.Storage = new(Storage)
	}
	offset += a.Storage.SizeSSZ()

	// Field (3) 'Storage'
	if dst, err = a.Storage.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Account object
func (a *Account) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 68 {
		return ssz.ErrSize
	}

	tail := buf
	var o3 uint64

	// Field (0) 'PublicKey'
	if cap(a.PublicKey) == 0 {
		a.PublicKey = make([]byte, 0, len(buf[0:48]))
	}
	a.PublicKey = append(a.PublicKey, buf[0:48]...)

	// Field (1) 'Nonce'
	a.Nonce = ssz.UnmarshallUint64(buf[48:56])

	// Field (2) 'Balance'
	a.Balance = ssz.UnmarshallUint64(buf[56:64])

	// Offset (3) 'Storage'
	if o3 = ssz.ReadOffset(buf[64:68]); o3 > size {
		return ssz.ErrOffset
	}

	if o3 < 68 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (3) 'Storage'
	{
		buf = tail[o3:]
		if a.Storage == nil {
			a.Storage = new(Storage)
		}
		if err = a.Storage.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Account object
func (a *Account) SizeSSZ() (size int) {
	size = 68

	// Field (3) 'Storage'
	if a.Storage == nil {
		a.Storage = new(Storage)
	}
	size += a.Storage.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Account object
func (a *Account) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Account object with a hasher
func (a *Account) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'PublicKey'
	if len(a.PublicKey) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(a.PublicKey)

	// Field (1) 'Nonce'
	hh.PutUint64(a.Nonce)

	// Field (2) 'Balance'
	hh.PutUint64(a.Balance)

	// Field (3) 'Storage'
	if err = a.Storage.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Attestation object
func (a *Attestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Attestation object to a target array
func (a *Attestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(228)

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(a.AggregationBits)

	// Field (1) 'Data'
	if a.Data != nil {
		if dst, err = a.Data.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Signature'
	if len(a.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.Signature...)

	// Field (0) 'AggregationBits'
	if len(a.AggregationBits) > 2048 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.AggregationBits...)

	return
}

// UnmarshalSSZ ssz unmarshals the Attestation object
func (a *Attestation) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 228 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'AggregationBits'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 228 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Data'
	if a.Data == nil {
		a.Data = new(AttestationData)
	}
	if err = a.Data.UnmarshalSSZ(buf[4:132]); err != nil {
		return err
	}

	// Field (2) 'Signature'
	if cap(a.Signature) == 0 {
		a.Signature = make([]byte, 0, len(buf[132:228]))
	}
	a.Signature = append(a.Signature, buf[132:228]...)

	// Field (0) 'AggregationBits'
	{
		buf = tail[o0:]
		if err = ssz.ValidateBitlist(buf, 2048); err != nil {
			return err
		}
		if cap(a.AggregationBits) == 0 {
			a.AggregationBits = make([]byte, 0, len(buf))
		}
		a.AggregationBits = append(a.AggregationBits, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Attestation object
func (a *Attestation) SizeSSZ() (size int) {
	size = 228

	// Field (0) 'AggregationBits'
	size += len(a.AggregationBits)

	return
}

// HashTreeRoot ssz hashes the Attestation object
func (a *Attestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Attestation object with a hasher
func (a *Attestation) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'AggregationBits'
	if len(a.AggregationBits) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(a.AggregationBits, 2048)

	// Field (1) 'Data'
	if a.Data != nil {
		if err = a.Data.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (2) 'Signature'
	if len(a.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(a.Signature)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the AggregateAttestationAndProof object
func (a *AggregateAttestationAndProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AggregateAttestationAndProof object to a target array
func (a *AggregateAttestationAndProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(108)

	// Field (0) 'AggregatorIndex'
	dst = ssz.MarshalUint64(dst, uint64(a.AggregatorIndex))

	// Offset (1) 'Aggregate'
	dst = ssz.WriteOffset(dst, offset)
	if a.Aggregate == nil {
		a.Aggregate = new(Attestation)
	}
	offset += a.Aggregate.SizeSSZ()

	// Field (2) 'SelectionProof'
	if len(a.SelectionProof) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.SelectionProof...)

	// Field (1) 'Aggregate'
	if dst, err = a.Aggregate.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AggregateAttestationAndProof object
func (a *AggregateAttestationAndProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 108 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'AggregatorIndex'
	a.AggregatorIndex = ValidatorIndex(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'Aggregate'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 108 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'SelectionProof'
	if cap(a.SelectionProof) == 0 {
		a.SelectionProof = make([]byte, 0, len(buf[12:108]))
	}
	a.SelectionProof = append(a.SelectionProof, buf[12:108]...)

	// Field (1) 'Aggregate'
	{
		buf = tail[o1:]
		if a.Aggregate == nil {
			a.Aggregate = new(Attestation)
		}
		if err = a.Aggregate.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AggregateAttestationAndProof object
func (a *AggregateAttestationAndProof) SizeSSZ() (size int) {
	size = 108

	// Field (1) 'Aggregate'
	if a.Aggregate == nil {
		a.Aggregate = new(Attestation)
	}
	size += a.Aggregate.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the AggregateAttestationAndProof object
func (a *AggregateAttestationAndProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AggregateAttestationAndProof object with a hasher
func (a *AggregateAttestationAndProof) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'AggregatorIndex'
	hh.PutUint64(uint64(a.AggregatorIndex))

	// Field (1) 'Aggregate'
	if err = a.Aggregate.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'SelectionProof'
	if len(a.SelectionProof) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(a.SelectionProof)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the SignedAggregateAttestationAndProof object
func (s *SignedAggregateAttestationAndProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedAggregateAttestationAndProof object to a target array
func (s *SignedAggregateAttestationAndProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(100)

	// Offset (0) 'Message'
	dst = ssz.WriteOffset(dst, offset)
	if s.Message == nil {
		s.Message = new(AggregateAttestationAndProof)
	}
	offset += s.Message.SizeSSZ()

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Signature...)

	// Field (0) 'Message'
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedAggregateAttestationAndProof object
func (s *SignedAggregateAttestationAndProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 100 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Message'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 100 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[4:100]))
	}
	s.Signature = append(s.Signature, buf[4:100]...)

	// Field (0) 'Message'
	{
		buf = tail[o0:]
		if s.Message == nil {
			s.Message = new(AggregateAttestationAndProof)
		}
		if err = s.Message.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedAggregateAttestationAndProof object
func (s *SignedAggregateAttestationAndProof) SizeSSZ() (size int) {
	size = 100

	// Field (0) 'Message'
	if s.Message == nil {
		s.Message = new(AggregateAttestationAndProof)
	}
	size += s.Message.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedAggregateAttestationAndProof object
func (s *SignedAggregateAttestationAndProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedAggregateAttestationAndProof object with a hasher
func (s *SignedAggregateAttestationAndProof) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the AttestationData object
func (a *AttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationData object to a target array
func (a *AttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(a.Slot))

	// Field (1) 'CommitteeIndex'
	dst = ssz.MarshalUint64(dst, uint64(a.CommitteeIndex))

	// Field (2) 'BeaconBlockRoot'
	if len(a.BeaconBlockRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.BeaconBlockRoot...)

	// Field (3) 'Source'
	if a.Source != nil {
		if dst, err = a.Source.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'Target'
	if a.Target != nil {
		if dst, err = a.Target.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationData object
func (a *AttestationData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 128 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	a.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'CommitteeIndex'
	a.CommitteeIndex = CommitteeIndex(ssz.UnmarshallUint64(buf[8:16]))

	// Field (2) 'BeaconBlockRoot'
	if cap(a.BeaconBlockRoot) == 0 {
		a.BeaconBlockRoot = make([]byte, 0, len(buf[16:48]))
	}
	a.BeaconBlockRoot = append(a.BeaconBlockRoot, buf[16:48]...)

	// Field (3) 'Source'
	if a.Source == nil {
		a.Source = new(Checkpoint)
	}
	if err = a.Source.UnmarshalSSZ(buf[48:88]); err != nil {
		return err
	}

	// Field (4) 'Target'
	if a.Target == nil {
		a.Target = new(Checkpoint)
	}
	if err = a.Target.UnmarshalSSZ(buf[88:128]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationData object
func (a *AttestationData) SizeSSZ() (size int) {
	size = 128
	return
}

// HashTreeRoot ssz hashes the AttestationData object
func (a *AttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationData object with a hasher
func (a *AttestationData) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(a.Slot))

	// Field (1) 'CommitteeIndex'
	hh.PutUint64(uint64(a.CommitteeIndex))

	// Field (2) 'BeaconBlockRoot'
	if len(a.BeaconBlockRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(a.BeaconBlockRoot)

	// Field (3) 'Source'
	if a.Source != nil {
		if err = a.Source.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (4) 'Target'
	if a.Target != nil {
		if err = a.Target.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Checkpoint object
func (c *Checkpoint) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Checkpoint object to a target array
func (c *Checkpoint) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Epoch'
	dst = ssz.MarshalUint64(dst, uint64(c.Epoch))

	// Field (1) 'Root'
	if len(c.Root) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, c.Root...)

	return
}

// UnmarshalSSZ ssz unmarshals the Checkpoint object
func (c *Checkpoint) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 40 {
		return ssz.ErrSize
	}

	// Field (0) 'Epoch'
	c.Epoch = Epoch(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'Root'
	if cap(c.Root) == 0 {
		c.Root = make([]byte, 0, len(buf[8:40]))
	}
	c.Root = append(c.Root, buf[8:40]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Checkpoint object
func (c *Checkpoint) SizeSSZ() (size int) {
	size = 40
	return
}

// HashTreeRoot ssz hashes the Checkpoint object
func (c *Checkpoint) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Checkpoint object with a hasher
func (c *Checkpoint) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Epoch'
	hh.PutUint64(uint64(c.Epoch))

	// Field (1) 'Root'
	if len(c.Root) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(c.Root)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(84)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	if len(b.ParentRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.ParentRoot...)

	// Field (3) 'StateRoot'
	if len(b.StateRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.StateRoot...)

	// Offset (4) 'Body'
	dst = ssz.WriteOffset(dst, offset)
	if b.Body == nil {
		b.Body = new(BlockBody)
	}
	offset += b.Body.SizeSSZ()

	// Field (4) 'Body'
	if dst, err = b.Body.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 84 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Slot'
	b.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ValidatorIndex(ssz.UnmarshallUint64(buf[8:16]))

	// Field (2) 'ParentRoot'
	if cap(b.ParentRoot) == 0 {
		b.ParentRoot = make([]byte, 0, len(buf[16:48]))
	}
	b.ParentRoot = append(b.ParentRoot, buf[16:48]...)

	// Field (3) 'StateRoot'
	if cap(b.StateRoot) == 0 {
		b.StateRoot = make([]byte, 0, len(buf[48:80]))
	}
	b.StateRoot = append(b.StateRoot, buf[48:80]...)

	// Offset (4) 'Body'
	if o4 = ssz.ReadOffset(buf[80:84]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 84 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Body'
	{
		buf = tail[o4:]
		if b.Body == nil {
			b.Body = new(BlockBody)
		}
		if err = b.Body.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 84

	// Field (4) 'Body'
	if b.Body == nil {
		b.Body = new(BlockBody)
	}
	size += b.Body.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Block object
func (b *Block) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the Block object with a hasher
func (b *Block) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	if len(b.ParentRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.ParentRoot)

	// Field (3) 'StateRoot'
	if len(b.StateRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.StateRoot)

	// Field (4) 'Body'
	if err = b.Body.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the SignedBlock object
func (s *SignedBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBlock object to a target array
func (s *SignedBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(100)

	// Offset (0) 'Block'
	dst = ssz.WriteOffset(dst, offset)
	if s.Block == nil {
		s.Block = new(Block)
	}
	offset += s.Block.SizeSSZ()

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Signature...)

	// Field (0) 'Block'
	if dst, err = s.Block.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBlock object
func (s *SignedBlock) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 100 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Block'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 100 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[4:100]))
	}
	s.Signature = append(s.Signature, buf[4:100]...)

	// Field (0) 'Block'
	{
		buf = tail[o0:]
		if s.Block == nil {
			s.Block = new(Block)
		}
		if err = s.Block.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBlock object
func (s *SignedBlock) SizeSSZ() (size int) {
	size = 100

	// Field (0) 'Block'
	if s.Block == nil {
		s.Block = new(Block)
	}
	size += s.Block.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedBlock object
func (s *SignedBlock) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBlock object with a hasher
func (s *SignedBlock) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Block'
	if err = s.Block.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the BlockBody object
func (b *BlockBody) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockBody object to a target array
func (b *BlockBody) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(144)

	// Field (0) 'RandaoReveal'
	if len(b.RandaoReveal) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.RandaoReveal...)

	// Field (1) 'Graffiti'
	if len(b.Graffiti) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Graffiti...)

	// Offset (2) 'Txs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Txs) * 2448

	// Offset (3) 'ProposerSlashings'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.ProposerSlashings) * 416

	// Offset (4) 'AttesterSlashings'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		offset += 4
		offset += b.AttesterSlashings[ii].SizeSSZ()
	}

	// Offset (5) 'Attestations'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Attestations); ii++ {
		offset += 4
		offset += b.Attestations[ii].SizeSSZ()
	}

	// Field (2) 'Txs'
	if len(b.Txs) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(b.Txs); ii++ {
		if dst, err = b.Txs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'ProposerSlashings'
	if len(b.ProposerSlashings) > 16 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(b.ProposerSlashings); ii++ {
		if dst, err = b.ProposerSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'AttesterSlashings'
	if len(b.AttesterSlashings) > 2 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(b.AttesterSlashings)
		for ii := 0; ii < len(b.AttesterSlashings); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.AttesterSlashings[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		if dst, err = b.AttesterSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'Attestations'
	if len(b.Attestations) > 128 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(b.Attestations)
		for ii := 0; ii < len(b.Attestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Attestations[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Attestations); ii++ {
		if dst, err = b.Attestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockBody object
func (b *BlockBody) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 144 {
		return ssz.ErrSize
	}

	tail := buf
	var o2, o3, o4, o5 uint64

	// Field (0) 'RandaoReveal'
	if cap(b.RandaoReveal) == 0 {
		b.RandaoReveal = make([]byte, 0, len(buf[0:96]))
	}
	b.RandaoReveal = append(b.RandaoReveal, buf[0:96]...)

	// Field (1) 'Graffiti'
	if cap(b.Graffiti) == 0 {
		b.Graffiti = make([]byte, 0, len(buf[96:128]))
	}
	b.Graffiti = append(b.Graffiti, buf[96:128]...)

	// Offset (2) 'Txs'
	if o2 = ssz.ReadOffset(buf[128:132]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 < 144 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (3) 'ProposerSlashings'
	if o3 = ssz.ReadOffset(buf[132:136]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'AttesterSlashings'
	if o4 = ssz.ReadOffset(buf[136:140]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Offset (5) 'Attestations'
	if o5 = ssz.ReadOffset(buf[140:144]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Field (2) 'Txs'
	{
		buf = tail[o2:o3]
		num, err := ssz.DivideInt2(len(buf), 2448, 1024)
		if err != nil {
			return err
		}
		b.Txs = make([]*SignedTransaction, num)
		for ii := 0; ii < num; ii++ {
			if b.Txs[ii] == nil {
				b.Txs[ii] = new(SignedTransaction)
			}
			if err = b.Txs[ii].UnmarshalSSZ(buf[ii*2448 : (ii+1)*2448]); err != nil {
				return err
			}
		}
	}

	// Field (3) 'ProposerSlashings'
	{
		buf = tail[o3:o4]
		num, err := ssz.DivideInt2(len(buf), 416, 16)
		if err != nil {
			return err
		}
		b.ProposerSlashings = make([]*ProposerSlashing, num)
		for ii := 0; ii < num; ii++ {
			if b.ProposerSlashings[ii] == nil {
				b.ProposerSlashings[ii] = new(ProposerSlashing)
			}
			if err = b.ProposerSlashings[ii].UnmarshalSSZ(buf[ii*416 : (ii+1)*416]); err != nil {
				return err
			}
		}
	}

	// Field (4) 'AttesterSlashings'
	{
		buf = tail[o4:o5]
		num, err := ssz.DecodeDynamicLength(buf, 2)
		if err != nil {
			return err
		}
		b.AttesterSlashings = make([]*AttesterSlashing, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.AttesterSlashings[indx] == nil {
				b.AttesterSlashings[indx] = new(AttesterSlashing)
			}
			if err = b.AttesterSlashings[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (5) 'Attestations'
	{
		buf = tail[o5:]
		num, err := ssz.DecodeDynamicLength(buf, 128)
		if err != nil {
			return err
		}
		b.Attestations = make([]*Attestation, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Attestations[indx] == nil {
				b.Attestations[indx] = new(Attestation)
			}
			if err = b.Attestations[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockBody object
func (b *BlockBody) SizeSSZ() (size int) {
	size = 144

	// Field (2) 'Txs'
	size += len(b.Txs) * 2448

	// Field (3) 'ProposerSlashings'
	size += len(b.ProposerSlashings) * 416

	// Field (4) 'AttesterSlashings'
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		size += 4
		size += b.AttesterSlashings[ii].SizeSSZ()
	}

	// Field (5) 'Attestations'
	for ii := 0; ii < len(b.Attestations); ii++ {
		size += 4
		size += b.Attestations[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the BlockBody object
func (b *BlockBody) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockBody object with a hasher
func (b *BlockBody) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'RandaoReveal'
	if len(b.RandaoReveal) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.RandaoReveal)

	// Field (1) 'Graffiti'
	if len(b.Graffiti) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.Graffiti)

	// Field (2) 'Txs'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Txs))
		if num > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Txs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1024)
	}

	// Field (3) 'ProposerSlashings'
	{
		subIndx := hh.Index()
		num := uint64(len(b.ProposerSlashings))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.ProposerSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (4) 'AttesterSlashings'
	{
		subIndx := hh.Index()
		num := uint64(len(b.AttesterSlashings))
		if num > 2 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.AttesterSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2)
	}

	// Field (5) 'Attestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Attestations))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Attestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the ProposerSlashing object
func (p *ProposerSlashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposerSlashing object to a target array
func (p *ProposerSlashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Header_1'
	if p.Header_1 != nil {
		if dst, err = p.Header_1.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Header_2'
	if p.Header_2 != nil {
		if dst, err = p.Header_2.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProposerSlashing object
func (p *ProposerSlashing) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 416 {
		return ssz.ErrSize
	}

	// Field (0) 'Header_1'
	if p.Header_1 == nil {
		p.Header_1 = new(SignedBlockHeader)
	}
	if err = p.Header_1.UnmarshalSSZ(buf[0:208]); err != nil {
		return err
	}

	// Field (1) 'Header_2'
	if p.Header_2 == nil {
		p.Header_2 = new(SignedBlockHeader)
	}
	if err = p.Header_2.UnmarshalSSZ(buf[208:416]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposerSlashing object
func (p *ProposerSlashing) SizeSSZ() (size int) {
	size = 416
	return
}

// HashTreeRoot ssz hashes the ProposerSlashing object
func (p *ProposerSlashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProposerSlashing object with a hasher
func (p *ProposerSlashing) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Header_1'
	if p.Header_1 != nil {
		if err = p.Header_1.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (1) 'Header_2'
	if p.Header_2 != nil {
		if err = p.Header_2.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the AttesterSlashing object
func (a *AttesterSlashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttesterSlashing object to a target array
func (a *AttesterSlashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Attestation_1'
	dst = ssz.WriteOffset(dst, offset)
	if a.Attestation_1 == nil {
		a.Attestation_1 = new(IndexedAttestation)
	}
	offset += a.Attestation_1.SizeSSZ()

	// Offset (1) 'Attestation_2'
	dst = ssz.WriteOffset(dst, offset)
	if a.Attestation_2 == nil {
		a.Attestation_2 = new(IndexedAttestation)
	}
	offset += a.Attestation_2.SizeSSZ()

	// Field (0) 'Attestation_1'
	if dst, err = a.Attestation_1.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Attestation_2'
	if dst, err = a.Attestation_2.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttesterSlashing object
func (a *AttesterSlashing) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Attestation_1'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 8 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Attestation_2'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Attestation_1'
	{
		buf = tail[o0:o1]
		if a.Attestation_1 == nil {
			a.Attestation_1 = new(IndexedAttestation)
		}
		if err = a.Attestation_1.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Attestation_2'
	{
		buf = tail[o1:]
		if a.Attestation_2 == nil {
			a.Attestation_2 = new(IndexedAttestation)
		}
		if err = a.Attestation_2.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AttesterSlashing object
func (a *AttesterSlashing) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Attestation_1'
	if a.Attestation_1 == nil {
		a.Attestation_1 = new(IndexedAttestation)
	}
	size += a.Attestation_1.SizeSSZ()

	// Field (1) 'Attestation_2'
	if a.Attestation_2 == nil {
		a.Attestation_2 = new(IndexedAttestation)
	}
	size += a.Attestation_2.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the AttesterSlashing object
func (a *AttesterSlashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttesterSlashing object with a hasher
func (a *AttesterSlashing) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Attestation_1'
	if err = a.Attestation_1.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Attestation_2'
	if err = a.Attestation_2.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the BlockHeader object
func (b *BlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockHeader object to a target array
func (b *BlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	if len(b.ParentRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.ParentRoot...)

	// Field (3) 'StateRoot'
	if len(b.StateRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.StateRoot...)

	// Field (4) 'BodyRoot'
	if len(b.BodyRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.BodyRoot...)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockHeader object
func (b *BlockHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 112 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	b.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ValidatorIndex(ssz.UnmarshallUint64(buf[8:16]))

	// Field (2) 'ParentRoot'
	if cap(b.ParentRoot) == 0 {
		b.ParentRoot = make([]byte, 0, len(buf[16:48]))
	}
	b.ParentRoot = append(b.ParentRoot, buf[16:48]...)

	// Field (3) 'StateRoot'
	if cap(b.StateRoot) == 0 {
		b.StateRoot = make([]byte, 0, len(buf[48:80]))
	}
	b.StateRoot = append(b.StateRoot, buf[48:80]...)

	// Field (4) 'BodyRoot'
	if cap(b.BodyRoot) == 0 {
		b.BodyRoot = make([]byte, 0, len(buf[80:112]))
	}
	b.BodyRoot = append(b.BodyRoot, buf[80:112]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockHeader object
func (b *BlockHeader) SizeSSZ() (size int) {
	size = 112
	return
}

// HashTreeRoot ssz hashes the BlockHeader object
func (b *BlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockHeader object with a hasher
func (b *BlockHeader) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	if len(b.ParentRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.ParentRoot)

	// Field (3) 'StateRoot'
	if len(b.StateRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.StateRoot)

	// Field (4) 'BodyRoot'
	if len(b.BodyRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(b.BodyRoot)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the SignedBlockHeader object
func (s *SignedBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBlockHeader object to a target array
func (s *SignedBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Header'
	if s.Header != nil {
		if dst, err = s.Header.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBlockHeader object
func (s *SignedBlockHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 208 {
		return ssz.ErrSize
	}

	// Field (0) 'Header'
	if s.Header == nil {
		s.Header = new(BlockHeader)
	}
	if err = s.Header.UnmarshalSSZ(buf[0:112]); err != nil {
		return err
	}

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[112:208]))
	}
	s.Signature = append(s.Signature, buf[112:208]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBlockHeader object
func (s *SignedBlockHeader) SizeSSZ() (size int) {
	size = 208
	return
}

// HashTreeRoot ssz hashes the SignedBlockHeader object
func (s *SignedBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBlockHeader object with a hasher
func (s *SignedBlockHeader) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	if s.Header != nil {
		if err = s.Header.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the IndexedAttestation object
func (i *IndexedAttestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(i)
}

// MarshalSSZTo ssz marshals the IndexedAttestation object to a target array
func (i *IndexedAttestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(228)

	// Offset (0) 'AttestingIndices'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(i.AttestingIndices) * 8

	// Field (1) 'Data'
	if i.Data != nil {
		if dst, err = i.Data.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Signature'
	if len(i.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, i.Signature...)

	// Field (0) 'AttestingIndices'
	if len(i.AttestingIndices) > 2048 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(i.AttestingIndices); ii++ {
		dst = ssz.MarshalUint64(dst, i.AttestingIndices[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the IndexedAttestation object
func (i *IndexedAttestation) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 228 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'AttestingIndices'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 228 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Data'
	if i.Data == nil {
		i.Data = new(AttestationData)
	}
	if err = i.Data.UnmarshalSSZ(buf[4:132]); err != nil {
		return err
	}

	// Field (2) 'Signature'
	if cap(i.Signature) == 0 {
		i.Signature = make([]byte, 0, len(buf[132:228]))
	}
	i.Signature = append(i.Signature, buf[132:228]...)

	// Field (0) 'AttestingIndices'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 8, 2048)
		if err != nil {
			return err
		}
		i.AttestingIndices = ssz.ExtendUint64(i.AttestingIndices, num)
		for ii := 0; ii < num; ii++ {
			i.AttestingIndices[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the IndexedAttestation object
func (i *IndexedAttestation) SizeSSZ() (size int) {
	size = 228

	// Field (0) 'AttestingIndices'
	size += len(i.AttestingIndices) * 8

	return
}

// HashTreeRoot ssz hashes the IndexedAttestation object
func (i *IndexedAttestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the IndexedAttestation object with a hasher
func (i *IndexedAttestation) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'AttestingIndices'
	{
		if len(i.AttestingIndices) > 2048 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range i.AttestingIndices {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(i.AttestingIndices))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(2048, numItems, 8))
	}

	// Field (1) 'Data'
	if i.Data != nil {
		if err = i.Data.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (2) 'Signature'
	if len(i.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(i.Signature)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the StorageContract object
func (s *StorageContract) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the StorageContract object to a target array
func (s *StorageContract) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'CommitTxHash'
	if len(s.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.CommitTxHash...)

	// Field (1) 'ObjectHash'
	if len(s.ObjectHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.ObjectHash...)

	// Field (2) 'Size'
	dst = ssz.MarshalUint64(dst, s.Size)

	// Field (3) 'Owner'
	if len(s.Owner) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Owner...)

	// Field (4) 'Depot'
	if len(s.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Depot...)

	// Field (5) 'DepotDiscoveryId'
	if len(s.DepotDiscoveryId) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.DepotDiscoveryId...)

	// Field (6) 'Start'
	dst = ssz.MarshalUint64(dst, uint64(s.Start))

	// Field (7) 'End'
	dst = ssz.MarshalUint64(dst, uint64(s.End))

	// Field (8) 'Fee'
	dst = ssz.MarshalUint64(dst, s.Fee)

	// Field (9) 'Pledge'
	dst = ssz.MarshalUint64(dst, s.Pledge)

	// Field (10) 'Status'
	dst = ssz.MarshalUint32(dst, s.Status)

	// Field (11) 'StatusExpiration'
	dst = ssz.MarshalUint64(dst, uint64(s.StatusExpiration))

	// Field (12) 'Auditor'
	if len(s.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Auditor...)

	// Field (13) 'AuditHash'
	if len(s.AuditHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.AuditHash...)

	// Field (14) 'PorHash'
	if len(s.PorHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.PorHash...)

	return
}

// UnmarshalSSZ ssz unmarshals the StorageContract object
func (s *StorageContract) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 356 {
		return ssz.ErrSize
	}

	// Field (0) 'CommitTxHash'
	if cap(s.CommitTxHash) == 0 {
		s.CommitTxHash = make([]byte, 0, len(buf[0:32]))
	}
	s.CommitTxHash = append(s.CommitTxHash, buf[0:32]...)

	// Field (1) 'ObjectHash'
	if cap(s.ObjectHash) == 0 {
		s.ObjectHash = make([]byte, 0, len(buf[32:64]))
	}
	s.ObjectHash = append(s.ObjectHash, buf[32:64]...)

	// Field (2) 'Size'
	s.Size = ssz.UnmarshallUint64(buf[64:72])

	// Field (3) 'Owner'
	if cap(s.Owner) == 0 {
		s.Owner = make([]byte, 0, len(buf[72:120]))
	}
	s.Owner = append(s.Owner, buf[72:120]...)

	// Field (4) 'Depot'
	if cap(s.Depot) == 0 {
		s.Depot = make([]byte, 0, len(buf[120:168]))
	}
	s.Depot = append(s.Depot, buf[120:168]...)

	// Field (5) 'DepotDiscoveryId'
	if cap(s.DepotDiscoveryId) == 0 {
		s.DepotDiscoveryId = make([]byte, 0, len(buf[168:200]))
	}
	s.DepotDiscoveryId = append(s.DepotDiscoveryId, buf[168:200]...)

	// Field (6) 'Start'
	s.Start = Slot(ssz.UnmarshallUint64(buf[200:208]))

	// Field (7) 'End'
	s.End = Slot(ssz.UnmarshallUint64(buf[208:216]))

	// Field (8) 'Fee'
	s.Fee = ssz.UnmarshallUint64(buf[216:224])

	// Field (9) 'Pledge'
	s.Pledge = ssz.UnmarshallUint64(buf[224:232])

	// Field (10) 'Status'
	s.Status = ssz.UnmarshallUint32(buf[232:236])

	// Field (11) 'StatusExpiration'
	s.StatusExpiration = Slot(ssz.UnmarshallUint64(buf[236:244]))

	// Field (12) 'Auditor'
	if cap(s.Auditor) == 0 {
		s.Auditor = make([]byte, 0, len(buf[244:292]))
	}
	s.Auditor = append(s.Auditor, buf[244:292]...)

	// Field (13) 'AuditHash'
	if cap(s.AuditHash) == 0 {
		s.AuditHash = make([]byte, 0, len(buf[292:324]))
	}
	s.AuditHash = append(s.AuditHash, buf[292:324]...)

	// Field (14) 'PorHash'
	if cap(s.PorHash) == 0 {
		s.PorHash = make([]byte, 0, len(buf[324:356]))
	}
	s.PorHash = append(s.PorHash, buf[324:356]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the StorageContract object
func (s *StorageContract) SizeSSZ() (size int) {
	size = 356
	return
}

// HashTreeRoot ssz hashes the StorageContract object
func (s *StorageContract) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the StorageContract object with a hasher
func (s *StorageContract) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'CommitTxHash'
	if len(s.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.CommitTxHash)

	// Field (1) 'ObjectHash'
	if len(s.ObjectHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.ObjectHash)

	// Field (2) 'Size'
	hh.PutUint64(s.Size)

	// Field (3) 'Owner'
	if len(s.Owner) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Owner)

	// Field (4) 'Depot'
	if len(s.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Depot)

	// Field (5) 'DepotDiscoveryId'
	if len(s.DepotDiscoveryId) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.DepotDiscoveryId)

	// Field (6) 'Start'
	hh.PutUint64(uint64(s.Start))

	// Field (7) 'End'
	hh.PutUint64(uint64(s.End))

	// Field (8) 'Fee'
	hh.PutUint64(s.Fee)

	// Field (9) 'Pledge'
	hh.PutUint64(s.Pledge)

	// Field (10) 'Status'
	hh.PutUint32(s.Status)

	// Field (11) 'StatusExpiration'
	hh.PutUint64(uint64(s.StatusExpiration))

	// Field (12) 'Auditor'
	if len(s.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Auditor)

	// Field (13) 'AuditHash'
	if len(s.AuditHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.AuditHash)

	// Field (14) 'PorHash'
	if len(s.PorHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.PorHash)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Audit object
func (a *Audit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Audit object to a target array
func (a *Audit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(104)

	// Field (0) 'Auditor'
	if len(a.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.Auditor...)

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(a.Slot))

	// Field (2) 'EncodedHash'
	if len(a.EncodedHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, a.EncodedHash...)

	// Field (3) 'EncodedSize'
	dst = ssz.MarshalUint64(dst, a.EncodedSize)

	// Field (4) 'NumBlocks'
	dst = ssz.MarshalUint32(dst, a.NumBlocks)

	// Offset (5) 'Rands'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(a.Rands); ii++ {
		offset += 4
		offset += len(a.Rands[ii])
	}

	// Field (5) 'Rands'
	if len(a.Rands) > 64 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(a.Rands)
		for ii := 0; ii < len(a.Rands); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(a.Rands[ii])
		}
	}
	for ii := 0; ii < len(a.Rands); ii++ {
		if len(a.Rands[ii]) > 96 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, a.Rands[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Audit object
func (a *Audit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 104 {
		return ssz.ErrSize
	}

	tail := buf
	var o5 uint64

	// Field (0) 'Auditor'
	if cap(a.Auditor) == 0 {
		a.Auditor = make([]byte, 0, len(buf[0:48]))
	}
	a.Auditor = append(a.Auditor, buf[0:48]...)

	// Field (1) 'Slot'
	a.Slot = Slot(ssz.UnmarshallUint64(buf[48:56]))

	// Field (2) 'EncodedHash'
	if cap(a.EncodedHash) == 0 {
		a.EncodedHash = make([]byte, 0, len(buf[56:88]))
	}
	a.EncodedHash = append(a.EncodedHash, buf[56:88]...)

	// Field (3) 'EncodedSize'
	a.EncodedSize = ssz.UnmarshallUint64(buf[88:96])

	// Field (4) 'NumBlocks'
	a.NumBlocks = ssz.UnmarshallUint32(buf[96:100])

	// Offset (5) 'Rands'
	if o5 = ssz.ReadOffset(buf[100:104]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 < 104 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (5) 'Rands'
	{
		buf = tail[o5:]
		num, err := ssz.DecodeDynamicLength(buf, 64)
		if err != nil {
			return err
		}
		a.Rands = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 96 {
				return ssz.ErrBytesLength
			}
			if cap(a.Rands[indx]) == 0 {
				a.Rands[indx] = make([]byte, 0, len(buf))
			}
			a.Rands[indx] = append(a.Rands[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Audit object
func (a *Audit) SizeSSZ() (size int) {
	size = 104

	// Field (5) 'Rands'
	for ii := 0; ii < len(a.Rands); ii++ {
		size += 4
		size += len(a.Rands[ii])
	}

	return
}

// HashTreeRoot ssz hashes the Audit object
func (a *Audit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Audit object with a hasher
func (a *Audit) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Auditor'
	if len(a.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(a.Auditor)

	// Field (1) 'Slot'
	hh.PutUint64(uint64(a.Slot))

	// Field (2) 'EncodedHash'
	if len(a.EncodedHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(a.EncodedHash)

	// Field (3) 'EncodedSize'
	hh.PutUint64(a.EncodedSize)

	// Field (4) 'NumBlocks'
	hh.PutUint32(a.NumBlocks)

	// Field (5) 'Rands'
	{
		subIndx := hh.Index()
		num := uint64(len(a.Rands))
		if num > 64 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range a.Rands {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 96 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (96+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 64)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Challenge object
func (c *Challenge) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Challenge object to a target array
func (c *Challenge) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BlockIndex'
	dst = ssz.MarshalUint32(dst, c.BlockIndex)

	// Field (1) 'Coefficient'
	if len(c.Coefficient) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, c.Coefficient...)

	return
}

// UnmarshalSSZ ssz unmarshals the Challenge object
func (c *Challenge) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 36 {
		return ssz.ErrSize
	}

	// Field (0) 'BlockIndex'
	c.BlockIndex = ssz.UnmarshallUint32(buf[0:4])

	// Field (1) 'Coefficient'
	if cap(c.Coefficient) == 0 {
		c.Coefficient = make([]byte, 0, len(buf[4:36]))
	}
	c.Coefficient = append(c.Coefficient, buf[4:36]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Challenge object
func (c *Challenge) SizeSSZ() (size int) {
	size = 36
	return
}

// HashTreeRoot ssz hashes the Challenge object
func (c *Challenge) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Challenge object with a hasher
func (c *Challenge) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'BlockIndex'
	hh.PutUint32(c.BlockIndex)

	// Field (1) 'Coefficient'
	if len(c.Coefficient) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(c.Coefficient)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the PoR object
func (p *PoR) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PoR object to a target array
func (p *PoR) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(124)

	// Field (0) 'Start'
	dst = ssz.MarshalUint64(dst, uint64(p.Start))

	// Field (1) 'ObjectHash'
	if len(p.ObjectHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.ObjectHash...)

	// Field (2) 'AuditHash'
	if len(p.AuditHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.AuditHash...)

	// Field (3) 'Auditor'
	if len(p.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.Auditor...)

	// Offset (4) 'Challenges'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.Challenges) * 36

	// Field (4) 'Challenges'
	if len(p.Challenges) > 32 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(p.Challenges); ii++ {
		if dst, err = p.Challenges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the PoR object
func (p *PoR) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 124 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Start'
	p.Start = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ObjectHash'
	if cap(p.ObjectHash) == 0 {
		p.ObjectHash = make([]byte, 0, len(buf[8:40]))
	}
	p.ObjectHash = append(p.ObjectHash, buf[8:40]...)

	// Field (2) 'AuditHash'
	if cap(p.AuditHash) == 0 {
		p.AuditHash = make([]byte, 0, len(buf[40:72]))
	}
	p.AuditHash = append(p.AuditHash, buf[40:72]...)

	// Field (3) 'Auditor'
	if cap(p.Auditor) == 0 {
		p.Auditor = make([]byte, 0, len(buf[72:120]))
	}
	p.Auditor = append(p.Auditor, buf[72:120]...)

	// Offset (4) 'Challenges'
	if o4 = ssz.ReadOffset(buf[120:124]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 124 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Challenges'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 36, 32)
		if err != nil {
			return err
		}
		p.Challenges = make([]*Challenge, num)
		for ii := 0; ii < num; ii++ {
			if p.Challenges[ii] == nil {
				p.Challenges[ii] = new(Challenge)
			}
			if err = p.Challenges[ii].UnmarshalSSZ(buf[ii*36 : (ii+1)*36]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PoR object
func (p *PoR) SizeSSZ() (size int) {
	size = 124

	// Field (4) 'Challenges'
	size += len(p.Challenges) * 36

	return
}

// HashTreeRoot ssz hashes the PoR object
func (p *PoR) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PoR object with a hasher
func (p *PoR) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Start'
	hh.PutUint64(uint64(p.Start))

	// Field (1) 'ObjectHash'
	if len(p.ObjectHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(p.ObjectHash)

	// Field (2) 'AuditHash'
	if len(p.AuditHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(p.AuditHash)

	// Field (3) 'Auditor'
	if len(p.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(p.Auditor)

	// Field (4) 'Challenges'
	{
		subIndx := hh.Index()
		num := uint64(len(p.Challenges))
		if num > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range p.Challenges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 32)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Status object
func (s *Status) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the Status object to a target array
func (s *Status) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'FinalizedRoot'
	if len(s.FinalizedRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.FinalizedRoot...)

	// Field (1) 'FinalizedEpoch'
	dst = ssz.MarshalUint64(dst, uint64(s.FinalizedEpoch))

	// Field (2) 'HeadRoot'
	if len(s.HeadRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.HeadRoot...)

	// Field (3) 'HeadSlot'
	dst = ssz.MarshalUint64(dst, uint64(s.HeadSlot))

	return
}

// UnmarshalSSZ ssz unmarshals the Status object
func (s *Status) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 80 {
		return ssz.ErrSize
	}

	// Field (0) 'FinalizedRoot'
	if cap(s.FinalizedRoot) == 0 {
		s.FinalizedRoot = make([]byte, 0, len(buf[0:32]))
	}
	s.FinalizedRoot = append(s.FinalizedRoot, buf[0:32]...)

	// Field (1) 'FinalizedEpoch'
	s.FinalizedEpoch = Epoch(ssz.UnmarshallUint64(buf[32:40]))

	// Field (2) 'HeadRoot'
	if cap(s.HeadRoot) == 0 {
		s.HeadRoot = make([]byte, 0, len(buf[40:72]))
	}
	s.HeadRoot = append(s.HeadRoot, buf[40:72]...)

	// Field (3) 'HeadSlot'
	s.HeadSlot = Slot(ssz.UnmarshallUint64(buf[72:80]))

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Status object
func (s *Status) SizeSSZ() (size int) {
	size = 80
	return
}

// HashTreeRoot ssz hashes the Status object
func (s *Status) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the Status object with a hasher
func (s *Status) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'FinalizedRoot'
	if len(s.FinalizedRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.FinalizedRoot)

	// Field (1) 'FinalizedEpoch'
	hh.PutUint64(uint64(s.FinalizedEpoch))

	// Field (2) 'HeadRoot'
	if len(s.HeadRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.HeadRoot)

	// Field (3) 'HeadSlot'
	hh.PutUint64(uint64(s.HeadSlot))

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the BlocksByRangeRequest object
func (b *BlocksByRangeRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlocksByRangeRequest object to a target array
func (b *BlocksByRangeRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'StartSlot'
	dst = ssz.MarshalUint64(dst, uint64(b.StartSlot))

	// Field (1) 'Count'
	dst = ssz.MarshalUint64(dst, b.Count)

	// Field (2) 'Step'
	dst = ssz.MarshalUint64(dst, b.Step)

	return
}

// UnmarshalSSZ ssz unmarshals the BlocksByRangeRequest object
func (b *BlocksByRangeRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 24 {
		return ssz.ErrSize
	}

	// Field (0) 'StartSlot'
	b.StartSlot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'Count'
	b.Count = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'Step'
	b.Step = ssz.UnmarshallUint64(buf[16:24])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlocksByRangeRequest object
func (b *BlocksByRangeRequest) SizeSSZ() (size int) {
	size = 24
	return
}

// HashTreeRoot ssz hashes the BlocksByRangeRequest object
func (b *BlocksByRangeRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlocksByRangeRequest object with a hasher
func (b *BlocksByRangeRequest) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'StartSlot'
	hh.PutUint64(uint64(b.StartSlot))

	// Field (1) 'Count'
	hh.PutUint64(b.Count)

	// Field (2) 'Step'
	hh.PutUint64(b.Step)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Metadata object
func (m *Metadata) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the Metadata object to a target array
func (m *Metadata) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'SeqNumber'
	dst = ssz.MarshalUint64(dst, m.SeqNumber)

	// Field (1) 'Attnets'
	if len(m.Attnets) != 8 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, m.Attnets...)

	// Field (2) 'Syncnets'
	if len(m.Syncnets) != 1 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, m.Syncnets...)

	return
}

// UnmarshalSSZ ssz unmarshals the Metadata object
func (m *Metadata) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 17 {
		return ssz.ErrSize
	}

	// Field (0) 'SeqNumber'
	m.SeqNumber = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Attnets'
	if cap(m.Attnets) == 0 {
		m.Attnets = make([]byte, 0, len(buf[8:16]))
	}
	m.Attnets = append(m.Attnets, buf[8:16]...)

	// Field (2) 'Syncnets'
	if cap(m.Syncnets) == 0 {
		m.Syncnets = make([]byte, 0, len(buf[16:17]))
	}
	m.Syncnets = append(m.Syncnets, buf[16:17]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Metadata object
func (m *Metadata) SizeSSZ() (size int) {
	size = 17
	return
}

// HashTreeRoot ssz hashes the Metadata object
func (m *Metadata) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the Metadata object with a hasher
func (m *Metadata) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'SeqNumber'
	hh.PutUint64(m.SeqNumber)

	// Field (1) 'Attnets'
	if len(m.Attnets) != 8 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(m.Attnets)

	// Field (2) 'Syncnets'
	if len(m.Syncnets) != 1 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(m.Syncnets)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the SigningData object
func (s *SigningData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SigningData object to a target array
func (s *SigningData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	if len(s.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Hash...)

	// Field (1) 'Domain'
	if len(s.Domain) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Domain...)

	return
}

// UnmarshalSSZ ssz unmarshals the SigningData object
func (s *SigningData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 64 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	if cap(s.Hash) == 0 {
		s.Hash = make([]byte, 0, len(buf[0:32]))
	}
	s.Hash = append(s.Hash, buf[0:32]...)

	// Field (1) 'Domain'
	if cap(s.Domain) == 0 {
		s.Domain = make([]byte, 0, len(buf[32:64]))
	}
	s.Domain = append(s.Domain, buf[32:64]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SigningData object
func (s *SigningData) SizeSSZ() (size int) {
	size = 64
	return
}

// HashTreeRoot ssz hashes the SigningData object
func (s *SigningData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SigningData object with a hasher
func (s *SigningData) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	if len(s.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Hash)

	// Field (1) 'Domain'
	if len(s.Domain) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Domain)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the State object
func (s *State) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the State object to a target array
func (s *State) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(509)

	// Field (0) 'GenesisTime'
	dst = ssz.MarshalUint64(dst, s.GenesisTime)

	// Field (1) 'GenesisIdentifier'
	if len(s.GenesisIdentifier) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.GenesisIdentifier...)

	// Field (2) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(s.Slot))

	// Field (3) 'LatestBlockHeader'
	if s.LatestBlockHeader != nil {
		if dst, err = s.LatestBlockHeader.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'JustificationBits'
	if len(s.JustificationBits) != 1 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.JustificationBits...)

	// Field (5) 'PreviousJustifiedCheckpoint'
	if s.PreviousJustifiedCheckpoint != nil {
		if dst, err = s.PreviousJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (6) 'CurrentJustifiedCheckpoint'
	if s.CurrentJustifiedCheckpoint != nil {
		if dst, err = s.CurrentJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'FinalizedCheckpoint'
	if s.FinalizedCheckpoint != nil {
		if dst, err = s.FinalizedCheckpoint.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Offset (8) 'Balances'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Balances) * 8

	// Offset (9) 'InactivityScores'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.InactivityScores) * 8

	// Offset (10) 'PreviousEpochParticipation'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.PreviousEpochParticipation)

	// Offset (11) 'CurrentEpochParticipation'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.CurrentEpochParticipation)

	// Offset (12) 'Slashings'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Slashings) * 8

	// Field (13) 'AccountTrieRoot'
	if len(s.AccountTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.AccountTrieRoot...)

	// Field (14) 'ValidatorTrieRoot'
	if len(s.ValidatorTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.ValidatorTrieRoot...)

	// Field (15) 'AuditorTrieRoot'
	if len(s.AuditorTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.AuditorTrieRoot...)

	// Field (16) 'StorageTrieRoot'
	if len(s.StorageTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.StorageTrieRoot...)

	// Field (17) 'AuditQueueRoot'
	if len(s.AuditQueueRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.AuditQueueRoot...)

	// Field (18) 'EventQueueRoot'
	if len(s.EventQueueRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.EventQueueRoot...)

	// Field (19) 'ReserviorBalance'
	dst = ssz.MarshalUint64(dst, s.ReserviorBalance)

	// Offset (20) 'Storage'
	dst = ssz.WriteOffset(dst, offset)
	if s.Storage == nil {
		s.Storage = new(Storage)
	}
	offset += s.Storage.SizeSSZ()

	// Offset (21) 'RandaoMixes'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(s.RandaoMixes); ii++ {
		offset += 4
		offset += len(s.RandaoMixes[ii])
	}

	// Field (8) 'Balances'
	if len(s.Balances) > 1099511627776 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(s.Balances); ii++ {
		dst = ssz.MarshalUint64(dst, s.Balances[ii])
	}

	// Field (9) 'InactivityScores'
	if len(s.InactivityScores) > 1099511627776 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(s.InactivityScores); ii++ {
		dst = ssz.MarshalUint64(dst, s.InactivityScores[ii])
	}

	// Field (10) 'PreviousEpochParticipation'
	if len(s.PreviousEpochParticipation) > 1099511627776 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.PreviousEpochParticipation...)

	// Field (11) 'CurrentEpochParticipation'
	if len(s.CurrentEpochParticipation) > 1099511627776 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.CurrentEpochParticipation...)

	// Field (12) 'Slashings'
	if len(s.Slashings) > 8192 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(s.Slashings); ii++ {
		dst = ssz.MarshalUint64(dst, s.Slashings[ii])
	}

	// Field (20) 'Storage'
	if dst, err = s.Storage.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (21) 'RandaoMixes'
	if len(s.RandaoMixes) > 65536 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(s.RandaoMixes)
		for ii := 0; ii < len(s.RandaoMixes); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(s.RandaoMixes[ii])
		}
	}
	for ii := 0; ii < len(s.RandaoMixes); ii++ {
		if len(s.RandaoMixes[ii]) > 32 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, s.RandaoMixes[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the State object
func (s *State) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 509 {
		return ssz.ErrSize
	}

	tail := buf
	var o8, o9, o10, o11, o12, o20, o21 uint64

	// Field (0) 'GenesisTime'
	s.GenesisTime = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'GenesisIdentifier'
	if cap(s.GenesisIdentifier) == 0 {
		s.GenesisIdentifier = make([]byte, 0, len(buf[8:40]))
	}
	s.GenesisIdentifier = append(s.GenesisIdentifier, buf[8:40]...)

	// Field (2) 'Slot'
	s.Slot = Slot(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'LatestBlockHeader'
	if s.LatestBlockHeader == nil {
		s.LatestBlockHeader = new(BlockHeader)
	}
	if err = s.LatestBlockHeader.UnmarshalSSZ(buf[48:160]); err != nil {
		return err
	}

	// Field (4) 'JustificationBits'
	if cap(s.JustificationBits) == 0 {
		s.JustificationBits = make([]byte, 0, len(buf[160:161]))
	}
	s.JustificationBits = append(s.JustificationBits, buf[160:161]...)

	// Field (5) 'PreviousJustifiedCheckpoint'
	if s.PreviousJustifiedCheckpoint == nil {
		s.PreviousJustifiedCheckpoint = new(Checkpoint)
	}
	if err = s.PreviousJustifiedCheckpoint.UnmarshalSSZ(buf[161:201]); err != nil {
		return err
	}

	// Field (6) 'CurrentJustifiedCheckpoint'
	if s.CurrentJustifiedCheckpoint == nil {
		s.CurrentJustifiedCheckpoint = new(Checkpoint)
	}
	if err = s.CurrentJustifiedCheckpoint.UnmarshalSSZ(buf[201:241]); err != nil {
		return err
	}

	// Field (7) 'FinalizedCheckpoint'
	if s.FinalizedCheckpoint == nil {
		s.FinalizedCheckpoint = new(Checkpoint)
	}
	if err = s.FinalizedCheckpoint.UnmarshalSSZ(buf[241:281]); err != nil {
		return err
	}

	// Offset (8) 'Balances'
	if o8 = ssz.ReadOffset(buf[281:285]); o8 > size {
		return ssz.ErrOffset
	}

	if o8 < 509 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (9) 'InactivityScores'
	if o9 = ssz.ReadOffset(buf[285:289]); o9 > size || o8 > o9 {
		return ssz.ErrOffset
	}

	// Offset (10) 'PreviousEpochParticipation'
	if o10 = ssz.ReadOffset(buf[289:293]); o10 > size || o9 > o10 {
		return ssz.ErrOffset
	}

	// Offset (11) 'CurrentEpochParticipation'
	if o11 = ssz.ReadOffset(buf[293:297]); o11 > size || o10 > o11 {
		return ssz.ErrOffset
	}

	// Offset (12) 'Slashings'
	if o12 = ssz.ReadOffset(buf[297:301]); o12 > size || o11 > o12 {
		return ssz.ErrOffset
	}

	// Field (13) 'AccountTrieRoot'
	if cap(s.AccountTrieRoot) == 0 {
		s.AccountTrieRoot = make([]byte, 0, len(buf[301:333]))
	}
	s.AccountTrieRoot = append(s.AccountTrieRoot, buf[301:333]...)

	// Field (14) 'ValidatorTrieRoot'
	if cap(s.ValidatorTrieRoot) == 0 {
		s.ValidatorTrieRoot = make([]byte, 0, len(buf[333:365]))
	}
	s.ValidatorTrieRoot = append(s.ValidatorTrieRoot, buf[333:365]...)

	// Field (15) 'AuditorTrieRoot'
	if cap(s.AuditorTrieRoot) == 0 {
		s.AuditorTrieRoot = make([]byte, 0, len(buf[365:397]))
	}
	s.AuditorTrieRoot = append(s.AuditorTrieRoot, buf[365:397]...)

	// Field (16) 'StorageTrieRoot'
	if cap(s.StorageTrieRoot) == 0 {
		s.StorageTrieRoot = make([]byte, 0, len(buf[397:429]))
	}
	s.StorageTrieRoot = append(s.StorageTrieRoot, buf[397:429]...)

	// Field (17) 'AuditQueueRoot'
	if cap(s.AuditQueueRoot) == 0 {
		s.AuditQueueRoot = make([]byte, 0, len(buf[429:461]))
	}
	s.AuditQueueRoot = append(s.AuditQueueRoot, buf[429:461]...)

	// Field (18) 'EventQueueRoot'
	if cap(s.EventQueueRoot) == 0 {
		s.EventQueueRoot = make([]byte, 0, len(buf[461:493]))
	}
	s.EventQueueRoot = append(s.EventQueueRoot, buf[461:493]...)

	// Field (19) 'ReserviorBalance'
	s.ReserviorBalance = ssz.UnmarshallUint64(buf[493:501])

	// Offset (20) 'Storage'
	if o20 = ssz.ReadOffset(buf[501:505]); o20 > size || o12 > o20 {
		return ssz.ErrOffset
	}

	// Offset (21) 'RandaoMixes'
	if o21 = ssz.ReadOffset(buf[505:509]); o21 > size || o20 > o21 {
		return ssz.ErrOffset
	}

	// Field (8) 'Balances'
	{
		buf = tail[o8:o9]
		num, err := ssz.DivideInt2(len(buf), 8, 1099511627776)
		if err != nil {
			return err
		}
		s.Balances = ssz.ExtendUint64(s.Balances, num)
		for ii := 0; ii < num; ii++ {
			s.Balances[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}

	// Field (9) 'InactivityScores'
	{
		buf = tail[o9:o10]
		num, err := ssz.DivideInt2(len(buf), 8, 1099511627776)
		if err != nil {
			return err
		}
		s.InactivityScores = ssz.ExtendUint64(s.InactivityScores, num)
		for ii := 0; ii < num; ii++ {
			s.InactivityScores[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}

	// Field (10) 'PreviousEpochParticipation'
	{
		buf = tail[o10:o11]
		if len(buf) > 1099511627776 {
			return ssz.ErrBytesLength
		}
		if cap(s.PreviousEpochParticipation) == 0 {
			s.PreviousEpochParticipation = make([]byte, 0, len(buf))
		}
		s.PreviousEpochParticipation = append(s.PreviousEpochParticipation, buf...)
	}

	// Field (11) 'CurrentEpochParticipation'
	{
		buf = tail[o11:o12]
		if len(buf) > 1099511627776 {
			return ssz.ErrBytesLength
		}
		if cap(s.CurrentEpochParticipation) == 0 {
			s.CurrentEpochParticipation = make([]byte, 0, len(buf))
		}
		s.CurrentEpochParticipation = append(s.CurrentEpochParticipation, buf...)
	}

	// Field (12) 'Slashings'
	{
		buf = tail[o12:o20]
		num, err := ssz.DivideInt2(len(buf), 8, 8192)
		if err != nil {
			return err
		}
		s.Slashings = ssz.ExtendUint64(s.Slashings, num)
		for ii := 0; ii < num; ii++ {
			s.Slashings[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}

	// Field (20) 'Storage'
	{
		buf = tail[o20:o21]
		if s.Storage == nil {
			s.Storage = new(Storage)
		}
		if err = s.Storage.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (21) 'RandaoMixes'
	{
		buf = tail[o21:]
		num, err := ssz.DecodeDynamicLength(buf, 65536)
		if err != nil {
			return err
		}
		s.RandaoMixes = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 32 {
				return ssz.ErrBytesLength
			}
			if cap(s.RandaoMixes[indx]) == 0 {
				s.RandaoMixes[indx] = make([]byte, 0, len(buf))
			}
			s.RandaoMixes[indx] = append(s.RandaoMixes[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the State object
func (s *State) SizeSSZ() (size int) {
	size = 509

	// Field (8) 'Balances'
	size += len(s.Balances) * 8

	// Field (9) 'InactivityScores'
	size += len(s.InactivityScores) * 8

	// Field (10) 'PreviousEpochParticipation'
	size += len(s.PreviousEpochParticipation)

	// Field (11) 'CurrentEpochParticipation'
	size += len(s.CurrentEpochParticipation)

	// Field (12) 'Slashings'
	size += len(s.Slashings) * 8

	// Field (20) 'Storage'
	if s.Storage == nil {
		s.Storage = new(Storage)
	}
	size += s.Storage.SizeSSZ()

	// Field (21) 'RandaoMixes'
	for ii := 0; ii < len(s.RandaoMixes); ii++ {
		size += 4
		size += len(s.RandaoMixes[ii])
	}

	return
}

// HashTreeRoot ssz hashes the State object
func (s *State) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the State object with a hasher
func (s *State) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'GenesisTime'
	hh.PutUint64(s.GenesisTime)

	// Field (1) 'GenesisIdentifier'
	if len(s.GenesisIdentifier) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.GenesisIdentifier)

	// Field (2) 'Slot'
	hh.PutUint64(uint64(s.Slot))

	// Field (3) 'LatestBlockHeader'
	if s.LatestBlockHeader != nil {
		if err = s.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (4) 'JustificationBits'
	if len(s.JustificationBits) != 1 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.JustificationBits)

	// Field (5) 'PreviousJustifiedCheckpoint'
	if s.PreviousJustifiedCheckpoint != nil {
		if err = s.PreviousJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (6) 'CurrentJustifiedCheckpoint'
	if s.CurrentJustifiedCheckpoint != nil {
		if err = s.CurrentJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (7) 'FinalizedCheckpoint'
	if s.FinalizedCheckpoint != nil {
		if err = s.FinalizedCheckpoint.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (8) 'Balances'
	{
		if len(s.Balances) > 1099511627776 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Balances {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Balances))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1099511627776, numItems, 8))
	}

	// Field (9) 'InactivityScores'
	{
		if len(s.InactivityScores) > 1099511627776 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range s.InactivityScores {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.InactivityScores))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1099511627776, numItems, 8))
	}

	// Field (10) 'PreviousEpochParticipation'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.PreviousEpochParticipation))
		if byteLen > 1099511627776 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(s.PreviousEpochParticipation)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1099511627776+31)/32)
	}

	// Field (11) 'CurrentEpochParticipation'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.CurrentEpochParticipation))
		if byteLen > 1099511627776 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(s.CurrentEpochParticipation)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1099511627776+31)/32)
	}

	// Field (12) 'Slashings'
	{
		if len(s.Slashings) > 8192 {
			err = ssz.ErrListTooBig
			return
		}
		subIndx := hh.Index()
		for _, i := range s.Slashings {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.Slashings))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(8192, numItems, 8))
	}

	// Field (13) 'AccountTrieRoot'
	if len(s.AccountTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.AccountTrieRoot)

	// Field (14) 'ValidatorTrieRoot'
	if len(s.ValidatorTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.ValidatorTrieRoot)

	// Field (15) 'AuditorTrieRoot'
	if len(s.AuditorTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.AuditorTrieRoot)

	// Field (16) 'StorageTrieRoot'
	if len(s.StorageTrieRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.StorageTrieRoot)

	// Field (17) 'AuditQueueRoot'
	if len(s.AuditQueueRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.AuditQueueRoot)

	// Field (18) 'EventQueueRoot'
	if len(s.EventQueueRoot) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.EventQueueRoot)

	// Field (19) 'ReserviorBalance'
	hh.PutUint64(s.ReserviorBalance)

	// Field (20) 'Storage'
	if err = s.Storage.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (21) 'RandaoMixes'
	{
		subIndx := hh.Index()
		num := uint64(len(s.RandaoMixes))
		if num > 65536 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range s.RandaoMixes {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 32 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 65536)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Storage object
func (s *Storage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the Storage object to a target array
func (s *Storage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Field (0) 'NumContracts'
	dst = ssz.MarshalUint64(dst, s.NumContracts)

	// Offset (1) 'TotalSize'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.TotalSize)

	// Field (2) 'RewardRate'
	dst = ssz.MarshalUint64(dst, s.RewardRate)

	// Field (1) 'TotalSize'
	if len(s.TotalSize) > 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.TotalSize...)

	return
}

// UnmarshalSSZ ssz unmarshals the Storage object
func (s *Storage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'NumContracts'
	s.NumContracts = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'TotalSize'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 20 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'RewardRate'
	s.RewardRate = ssz.UnmarshallUint64(buf[12:20])

	// Field (1) 'TotalSize'
	{
		buf = tail[o1:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(s.TotalSize) == 0 {
			s.TotalSize = make([]byte, 0, len(buf))
		}
		s.TotalSize = append(s.TotalSize, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Storage object
func (s *Storage) SizeSSZ() (size int) {
	size = 20

	// Field (1) 'TotalSize'
	size += len(s.TotalSize)

	return
}

// HashTreeRoot ssz hashes the Storage object
func (s *Storage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the Storage object with a hasher
func (s *Storage) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'NumContracts'
	hh.PutUint64(s.NumContracts)

	// Field (1) 'TotalSize'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.TotalSize))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(s.TotalSize)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (2) 'RewardRate'
	hh.PutUint64(s.RewardRate)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Transaction object
func (t *Transaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transaction object to a target array
func (t *Transaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Type'
	dst = ssz.MarshalUint32(dst, t.Type)

	// Field (1) 'From'
	if len(t.From) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.From...)

	// Field (2) 'ChainId'
	dst = ssz.MarshalUint32(dst, t.ChainId)

	// Field (3) 'Nonce'
	dst = ssz.MarshalUint64(dst, t.Nonce)

	// Field (4) 'GasPrice'
	dst = ssz.MarshalUint64(dst, t.GasPrice)

	// Field (5) 'GasLimit'
	dst = ssz.MarshalUint64(dst, t.GasLimit)

	// Field (6) 'TxDataBalanceTransfer'
	if t.TxDataBalanceTransfer != nil {
		if dst, err = t.TxDataBalanceTransfer.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'TxDataValidatorDeposit'
	if t.TxDataValidatorDeposit != nil {
		if dst, err = t.TxDataValidatorDeposit.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (8) 'TxDataAuditorDeposit'
	if t.TxDataAuditorDeposit != nil {
		if dst, err = t.TxDataAuditorDeposit.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (9) 'TxDataObjectCommit'
	if t.TxDataObjectCommit != nil {
		if dst, err = t.TxDataObjectCommit.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (10) 'TxDataObjectAudit'
	if t.TxDataObjectAudit != nil {
		if dst, err = t.TxDataObjectAudit.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (11) 'TxDataObjectChallenge'
	if t.TxDataObjectChallenge != nil {
		if dst, err = t.TxDataObjectChallenge.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (12) 'TxDataObjectPoR'
	if t.TxDataObjectPoR != nil {
		if dst, err = t.TxDataObjectPoR.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Transaction object
func (t *Transaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 2352 {
		return ssz.ErrSize
	}

	// Field (0) 'Type'
	t.Type = ssz.UnmarshallUint32(buf[0:4])

	// Field (1) 'From'
	if cap(t.From) == 0 {
		t.From = make([]byte, 0, len(buf[4:52]))
	}
	t.From = append(t.From, buf[4:52]...)

	// Field (2) 'ChainId'
	t.ChainId = ssz.UnmarshallUint32(buf[52:56])

	// Field (3) 'Nonce'
	t.Nonce = ssz.UnmarshallUint64(buf[56:64])

	// Field (4) 'GasPrice'
	t.GasPrice = ssz.UnmarshallUint64(buf[64:72])

	// Field (5) 'GasLimit'
	t.GasLimit = ssz.UnmarshallUint64(buf[72:80])

	// Field (6) 'TxDataBalanceTransfer'
	if t.TxDataBalanceTransfer == nil {
		t.TxDataBalanceTransfer = new(TxDataBalanceTransfer)
	}
	if err = t.TxDataBalanceTransfer.UnmarshalSSZ(buf[80:136]); err != nil {
		return err
	}

	// Field (7) 'TxDataValidatorDeposit'
	if t.TxDataValidatorDeposit == nil {
		t.TxDataValidatorDeposit = new(TxDataValidatorDeposit)
	}
	if err = t.TxDataValidatorDeposit.UnmarshalSSZ(buf[136:144]); err != nil {
		return err
	}

	// Field (8) 'TxDataAuditorDeposit'
	if t.TxDataAuditorDeposit == nil {
		t.TxDataAuditorDeposit = new(TxDataAuditorDeposit)
	}
	if err = t.TxDataAuditorDeposit.UnmarshalSSZ(buf[144:664]); err != nil {
		return err
	}

	// Field (9) 'TxDataObjectCommit'
	if t.TxDataObjectCommit == nil {
		t.TxDataObjectCommit = new(TxDataObjectCommit)
	}
	if err = t.TxDataObjectCommit.UnmarshalSSZ(buf[664:908]); err != nil {
		return err
	}

	// Field (10) 'TxDataObjectAudit'
	if t.TxDataObjectAudit == nil {
		t.TxDataObjectAudit = new(TxDataObjectAudit)
	}
	if err = t.TxDataObjectAudit.UnmarshalSSZ(buf[908:1888]); err != nil {
		return err
	}

	// Field (11) 'TxDataObjectChallenge'
	if t.TxDataObjectChallenge == nil {
		t.TxDataObjectChallenge = new(TxDataObjectChallenge)
	}
	if err = t.TxDataObjectChallenge.UnmarshalSSZ(buf[1888:1968]); err != nil {
		return err
	}

	// Field (12) 'TxDataObjectPoR'
	if t.TxDataObjectPoR == nil {
		t.TxDataObjectPoR = new(TxDataObjectPoR)
	}
	if err = t.TxDataObjectPoR.UnmarshalSSZ(buf[1968:2352]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transaction object
func (t *Transaction) SizeSSZ() (size int) {
	size = 2352
	return
}

// HashTreeRoot ssz hashes the Transaction object
func (t *Transaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transaction object with a hasher
func (t *Transaction) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Type'
	hh.PutUint32(t.Type)

	// Field (1) 'From'
	if len(t.From) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.From)

	// Field (2) 'ChainId'
	hh.PutUint32(t.ChainId)

	// Field (3) 'Nonce'
	hh.PutUint64(t.Nonce)

	// Field (4) 'GasPrice'
	hh.PutUint64(t.GasPrice)

	// Field (5) 'GasLimit'
	hh.PutUint64(t.GasLimit)

	// Field (6) 'TxDataBalanceTransfer'
	if t.TxDataBalanceTransfer != nil {
		if err = t.TxDataBalanceTransfer.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (7) 'TxDataValidatorDeposit'
	if t.TxDataValidatorDeposit != nil {
		if err = t.TxDataValidatorDeposit.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (8) 'TxDataAuditorDeposit'
	if t.TxDataAuditorDeposit != nil {
		if err = t.TxDataAuditorDeposit.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (9) 'TxDataObjectCommit'
	if t.TxDataObjectCommit != nil {
		if err = t.TxDataObjectCommit.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (10) 'TxDataObjectAudit'
	if t.TxDataObjectAudit != nil {
		if err = t.TxDataObjectAudit.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (11) 'TxDataObjectChallenge'
	if t.TxDataObjectChallenge != nil {
		if err = t.TxDataObjectChallenge.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (12) 'TxDataObjectPoR'
	if t.TxDataObjectPoR != nil {
		if err = t.TxDataObjectPoR.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataBalanceTransfer object
func (t *TxDataBalanceTransfer) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataBalanceTransfer object to a target array
func (t *TxDataBalanceTransfer) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'To'
	if len(t.To) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.To...)

	// Field (1) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataBalanceTransfer object
func (t *TxDataBalanceTransfer) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'To'
	if cap(t.To) == 0 {
		t.To = make([]byte, 0, len(buf[0:48]))
	}
	t.To = append(t.To, buf[0:48]...)

	// Field (1) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataBalanceTransfer object
func (t *TxDataBalanceTransfer) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the TxDataBalanceTransfer object
func (t *TxDataBalanceTransfer) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataBalanceTransfer object with a hasher
func (t *TxDataBalanceTransfer) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'To'
	if len(t.To) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.To)

	// Field (1) 'Amount'
	hh.PutUint64(t.Amount)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataValidatorDeposit object
func (t *TxDataValidatorDeposit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataValidatorDeposit object to a target array
func (t *TxDataValidatorDeposit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataValidatorDeposit object
func (t *TxDataValidatorDeposit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 8 {
		return ssz.ErrSize
	}

	// Field (0) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[0:8])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataValidatorDeposit object
func (t *TxDataValidatorDeposit) SizeSSZ() (size int) {
	size = 8
	return
}

// HashTreeRoot ssz hashes the TxDataValidatorDeposit object
func (t *TxDataValidatorDeposit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataValidatorDeposit object with a hasher
func (t *TxDataValidatorDeposit) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Amount'
	hh.PutUint64(t.Amount)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataAuditorDeposit object
func (t *TxDataAuditorDeposit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataAuditorDeposit object to a target array
func (t *TxDataAuditorDeposit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Amount'
	dst = ssz.MarshalUint64(dst, t.Amount)

	// Field (1) 'Decoder'
	if len(t.Decoder) != 512 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Decoder...)

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataAuditorDeposit object
func (t *TxDataAuditorDeposit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 520 {
		return ssz.ErrSize
	}

	// Field (0) 'Amount'
	t.Amount = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Decoder'
	if cap(t.Decoder) == 0 {
		t.Decoder = make([]byte, 0, len(buf[8:520]))
	}
	t.Decoder = append(t.Decoder, buf[8:520]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataAuditorDeposit object
func (t *TxDataAuditorDeposit) SizeSSZ() (size int) {
	size = 520
	return
}

// HashTreeRoot ssz hashes the TxDataAuditorDeposit object
func (t *TxDataAuditorDeposit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataAuditorDeposit object with a hasher
func (t *TxDataAuditorDeposit) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Amount'
	hh.PutUint64(t.Amount)

	// Field (1) 'Decoder'
	if len(t.Decoder) != 512 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Decoder)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataObjectCommit object
func (t *TxDataObjectCommit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataObjectCommit object to a target array
func (t *TxDataObjectCommit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Owner'
	if len(t.Owner) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Owner...)

	// Field (1) 'Depot'
	if len(t.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Depot...)

	// Field (2) 'DepotDiscoveryId'
	if len(t.DepotDiscoveryId) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.DepotDiscoveryId...)

	// Field (3) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Hash...)

	// Field (4) 'Size'
	dst = ssz.MarshalUint64(dst, t.Size)

	// Field (5) 'EncodedHash'
	if len(t.EncodedHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.EncodedHash...)

	// Field (6) 'EncodedSize'
	dst = ssz.MarshalUint64(dst, t.EncodedSize)

	// Field (7) 'NumBlocks'
	dst = ssz.MarshalUint32(dst, t.NumBlocks)

	// Field (8) 'Duration'
	dst = ssz.MarshalUint64(dst, uint64(t.Duration))

	// Field (9) 'Fee'
	dst = ssz.MarshalUint64(dst, t.Fee)

	// Field (10) 'Pledge'
	dst = ssz.MarshalUint64(dst, t.Pledge)

	// Field (11) 'Deadline'
	dst = ssz.MarshalUint64(dst, uint64(t.Deadline))

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataObjectCommit object
func (t *TxDataObjectCommit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 244 {
		return ssz.ErrSize
	}

	// Field (0) 'Owner'
	if cap(t.Owner) == 0 {
		t.Owner = make([]byte, 0, len(buf[0:48]))
	}
	t.Owner = append(t.Owner, buf[0:48]...)

	// Field (1) 'Depot'
	if cap(t.Depot) == 0 {
		t.Depot = make([]byte, 0, len(buf[48:96]))
	}
	t.Depot = append(t.Depot, buf[48:96]...)

	// Field (2) 'DepotDiscoveryId'
	if cap(t.DepotDiscoveryId) == 0 {
		t.DepotDiscoveryId = make([]byte, 0, len(buf[96:128]))
	}
	t.DepotDiscoveryId = append(t.DepotDiscoveryId, buf[96:128]...)

	// Field (3) 'Hash'
	if cap(t.Hash) == 0 {
		t.Hash = make([]byte, 0, len(buf[128:160]))
	}
	t.Hash = append(t.Hash, buf[128:160]...)

	// Field (4) 'Size'
	t.Size = ssz.UnmarshallUint64(buf[160:168])

	// Field (5) 'EncodedHash'
	if cap(t.EncodedHash) == 0 {
		t.EncodedHash = make([]byte, 0, len(buf[168:200]))
	}
	t.EncodedHash = append(t.EncodedHash, buf[168:200]...)

	// Field (6) 'EncodedSize'
	t.EncodedSize = ssz.UnmarshallUint64(buf[200:208])

	// Field (7) 'NumBlocks'
	t.NumBlocks = ssz.UnmarshallUint32(buf[208:212])

	// Field (8) 'Duration'
	t.Duration = Slot(ssz.UnmarshallUint64(buf[212:220]))

	// Field (9) 'Fee'
	t.Fee = ssz.UnmarshallUint64(buf[220:228])

	// Field (10) 'Pledge'
	t.Pledge = ssz.UnmarshallUint64(buf[228:236])

	// Field (11) 'Deadline'
	t.Deadline = Slot(ssz.UnmarshallUint64(buf[236:244]))

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataObjectCommit object
func (t *TxDataObjectCommit) SizeSSZ() (size int) {
	size = 244
	return
}

// HashTreeRoot ssz hashes the TxDataObjectCommit object
func (t *TxDataObjectCommit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataObjectCommit object with a hasher
func (t *TxDataObjectCommit) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Owner'
	if len(t.Owner) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Owner)

	// Field (1) 'Depot'
	if len(t.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Depot)

	// Field (2) 'DepotDiscoveryId'
	if len(t.DepotDiscoveryId) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.DepotDiscoveryId)

	// Field (3) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Hash)

	// Field (4) 'Size'
	hh.PutUint64(t.Size)

	// Field (5) 'EncodedHash'
	if len(t.EncodedHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.EncodedHash)

	// Field (6) 'EncodedSize'
	hh.PutUint64(t.EncodedSize)

	// Field (7) 'NumBlocks'
	hh.PutUint32(t.NumBlocks)

	// Field (8) 'Duration'
	hh.PutUint64(uint64(t.Duration))

	// Field (9) 'Fee'
	hh.PutUint64(t.Fee)

	// Field (10) 'Pledge'
	hh.PutUint64(t.Pledge)

	// Field (11) 'Deadline'
	hh.PutUint64(uint64(t.Deadline))

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataObjectAudit object
func (t *TxDataObjectAudit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataObjectAudit object to a target array
func (t *TxDataObjectAudit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'CommitTxHash'
	if len(t.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.CommitTxHash...)

	// Field (1) 'Auditor'
	if len(t.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Auditor...)

	// Field (2) 'Depot'
	if len(t.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Depot...)

	// Field (3) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Hash...)

	// Field (4) 'Size'
	dst = ssz.MarshalUint64(dst, t.Size)

	// Field (5) 'EncodedHash'
	if len(t.EncodedHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.EncodedHash...)

	// Field (6) 'EncodedSize'
	dst = ssz.MarshalUint64(dst, t.EncodedSize)

	// Field (7) 'NumBlocks'
	dst = ssz.MarshalUint32(dst, t.NumBlocks)

	// Field (8) 'Rands'
	if len(t.Rands) != 8 {
		err = ssz.ErrVectorLength
		return
	}
	for ii := 0; ii < 8; ii++ {
		if len(t.Rands[ii]) != 96 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, t.Rands[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataObjectAudit object
func (t *TxDataObjectAudit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 980 {
		return ssz.ErrSize
	}

	// Field (0) 'CommitTxHash'
	if cap(t.CommitTxHash) == 0 {
		t.CommitTxHash = make([]byte, 0, len(buf[0:32]))
	}
	t.CommitTxHash = append(t.CommitTxHash, buf[0:32]...)

	// Field (1) 'Auditor'
	if cap(t.Auditor) == 0 {
		t.Auditor = make([]byte, 0, len(buf[32:80]))
	}
	t.Auditor = append(t.Auditor, buf[32:80]...)

	// Field (2) 'Depot'
	if cap(t.Depot) == 0 {
		t.Depot = make([]byte, 0, len(buf[80:128]))
	}
	t.Depot = append(t.Depot, buf[80:128]...)

	// Field (3) 'Hash'
	if cap(t.Hash) == 0 {
		t.Hash = make([]byte, 0, len(buf[128:160]))
	}
	t.Hash = append(t.Hash, buf[128:160]...)

	// Field (4) 'Size'
	t.Size = ssz.UnmarshallUint64(buf[160:168])

	// Field (5) 'EncodedHash'
	if cap(t.EncodedHash) == 0 {
		t.EncodedHash = make([]byte, 0, len(buf[168:200]))
	}
	t.EncodedHash = append(t.EncodedHash, buf[168:200]...)

	// Field (6) 'EncodedSize'
	t.EncodedSize = ssz.UnmarshallUint64(buf[200:208])

	// Field (7) 'NumBlocks'
	t.NumBlocks = ssz.UnmarshallUint32(buf[208:212])

	// Field (8) 'Rands'
	t.Rands = make([][]byte, 8)
	for ii := 0; ii < 8; ii++ {
		if cap(t.Rands[ii]) == 0 {
			t.Rands[ii] = make([]byte, 0, len(buf[212:980][ii*96:(ii+1)*96]))
		}
		t.Rands[ii] = append(t.Rands[ii], buf[212:980][ii*96:(ii+1)*96]...)
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataObjectAudit object
func (t *TxDataObjectAudit) SizeSSZ() (size int) {
	size = 980
	return
}

// HashTreeRoot ssz hashes the TxDataObjectAudit object
func (t *TxDataObjectAudit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataObjectAudit object with a hasher
func (t *TxDataObjectAudit) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'CommitTxHash'
	if len(t.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.CommitTxHash)

	// Field (1) 'Auditor'
	if len(t.Auditor) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Auditor)

	// Field (2) 'Depot'
	if len(t.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Depot)

	// Field (3) 'Hash'
	if len(t.Hash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Hash)

	// Field (4) 'Size'
	hh.PutUint64(t.Size)

	// Field (5) 'EncodedHash'
	if len(t.EncodedHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.EncodedHash)

	// Field (6) 'EncodedSize'
	hh.PutUint64(t.EncodedSize)

	// Field (7) 'NumBlocks'
	hh.PutUint32(t.NumBlocks)

	// Field (8) 'Rands'
	{
		if len(t.Rands) != 8 {
			err = ssz.ErrVectorLength
			return
		}
		subIndx := hh.Index()
		for _, i := range t.Rands {
			if len(i) != 96 {
				err = ssz.ErrBytesLength
				return
			}
			hh.PutBytes(i)
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataObjectChallenge object
func (t *TxDataObjectChallenge) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataObjectChallenge object to a target array
func (t *TxDataObjectChallenge) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Depot'
	if len(t.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Depot...)

	// Field (1) 'CommitTxHash'
	if len(t.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.CommitTxHash...)

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataObjectChallenge object
func (t *TxDataObjectChallenge) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 80 {
		return ssz.ErrSize
	}

	// Field (0) 'Depot'
	if cap(t.Depot) == 0 {
		t.Depot = make([]byte, 0, len(buf[0:48]))
	}
	t.Depot = append(t.Depot, buf[0:48]...)

	// Field (1) 'CommitTxHash'
	if cap(t.CommitTxHash) == 0 {
		t.CommitTxHash = make([]byte, 0, len(buf[48:80]))
	}
	t.CommitTxHash = append(t.CommitTxHash, buf[48:80]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataObjectChallenge object
func (t *TxDataObjectChallenge) SizeSSZ() (size int) {
	size = 80
	return
}

// HashTreeRoot ssz hashes the TxDataObjectChallenge object
func (t *TxDataObjectChallenge) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataObjectChallenge object with a hasher
func (t *TxDataObjectChallenge) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Depot'
	if len(t.Depot) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Depot)

	// Field (1) 'CommitTxHash'
	if len(t.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.CommitTxHash)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the TxDataObjectPoR object
func (t *TxDataObjectPoR) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the TxDataObjectPoR object to a target array
func (t *TxDataObjectPoR) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'CommitTxHash'
	if len(t.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.CommitTxHash...)

	// Field (1) 'BlockAggs'
	if len(t.BlockAggs) != 8 {
		err = ssz.ErrVectorLength
		return
	}
	for ii := 0; ii < 8; ii++ {
		if len(t.BlockAggs[ii]) != 32 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, t.BlockAggs[ii]...)
	}

	// Field (2) 'Sigma'
	if len(t.Sigma) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, t.Sigma...)

	return
}

// UnmarshalSSZ ssz unmarshals the TxDataObjectPoR object
func (t *TxDataObjectPoR) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 384 {
		return ssz.ErrSize
	}

	// Field (0) 'CommitTxHash'
	if cap(t.CommitTxHash) == 0 {
		t.CommitTxHash = make([]byte, 0, len(buf[0:32]))
	}
	t.CommitTxHash = append(t.CommitTxHash, buf[0:32]...)

	// Field (1) 'BlockAggs'
	t.BlockAggs = make([][]byte, 8)
	for ii := 0; ii < 8; ii++ {
		if cap(t.BlockAggs[ii]) == 0 {
			t.BlockAggs[ii] = make([]byte, 0, len(buf[32:288][ii*32:(ii+1)*32]))
		}
		t.BlockAggs[ii] = append(t.BlockAggs[ii], buf[32:288][ii*32:(ii+1)*32]...)
	}

	// Field (2) 'Sigma'
	if cap(t.Sigma) == 0 {
		t.Sigma = make([]byte, 0, len(buf[288:384]))
	}
	t.Sigma = append(t.Sigma, buf[288:384]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the TxDataObjectPoR object
func (t *TxDataObjectPoR) SizeSSZ() (size int) {
	size = 384
	return
}

// HashTreeRoot ssz hashes the TxDataObjectPoR object
func (t *TxDataObjectPoR) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the TxDataObjectPoR object with a hasher
func (t *TxDataObjectPoR) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'CommitTxHash'
	if len(t.CommitTxHash) != 32 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.CommitTxHash)

	// Field (1) 'BlockAggs'
	{
		if len(t.BlockAggs) != 8 {
			err = ssz.ErrVectorLength
			return
		}
		subIndx := hh.Index()
		for _, i := range t.BlockAggs {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (2) 'Sigma'
	if len(t.Sigma) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(t.Sigma)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the SignedTransaction object
func (s *SignedTransaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedTransaction object to a target array
func (s *SignedTransaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Tx'
	if s.Tx != nil {
		if dst, err = s.Tx.MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedTransaction object
func (s *SignedTransaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 2448 {
		return ssz.ErrSize
	}

	// Field (0) 'Tx'
	if s.Tx == nil {
		s.Tx = new(Transaction)
	}
	if err = s.Tx.UnmarshalSSZ(buf[0:2352]); err != nil {
		return err
	}

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[2352:2448]))
	}
	s.Signature = append(s.Signature, buf[2352:2448]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedTransaction object
func (s *SignedTransaction) SizeSSZ() (size int) {
	size = 2448
	return
}

// HashTreeRoot ssz hashes the SignedTransaction object
func (s *SignedTransaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedTransaction object with a hasher
func (s *SignedTransaction) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Tx'
	if s.Tx != nil {
		if err = s.Tx.HashTreeRootWith(hh); err != nil {
			return
		}
	}

	// Field (1) 'Signature'
	if len(s.Signature) != 96 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the Validator object
func (v *Validator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Validator object to a target array
func (v *Validator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'PublicKey'
	if len(v.PublicKey) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, v.PublicKey...)

	// Field (1) 'Slashed'
	dst = ssz.MarshalBool(dst, v.Slashed)

	// Field (2) 'ActivationEligibilityEpoch'
	dst = ssz.MarshalUint64(dst, uint64(v.ActivationEligibilityEpoch))

	// Field (3) 'ActivationEpoch'
	dst = ssz.MarshalUint64(dst, uint64(v.ActivationEpoch))

	// Field (4) 'ExitEpoch'
	dst = ssz.MarshalUint64(dst, uint64(v.ExitEpoch))

	// Field (5) 'WithdrawableEpoch'
	dst = ssz.MarshalUint64(dst, uint64(v.WithdrawableEpoch))

	return
}

// UnmarshalSSZ ssz unmarshals the Validator object
func (v *Validator) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 81 {
		return ssz.ErrSize
	}

	// Field (0) 'PublicKey'
	if cap(v.PublicKey) == 0 {
		v.PublicKey = make([]byte, 0, len(buf[0:48]))
	}
	v.PublicKey = append(v.PublicKey, buf[0:48]...)

	// Field (1) 'Slashed'
	v.Slashed = ssz.UnmarshalBool(buf[48:49])

	// Field (2) 'ActivationEligibilityEpoch'
	v.ActivationEligibilityEpoch = Epoch(ssz.UnmarshallUint64(buf[49:57]))

	// Field (3) 'ActivationEpoch'
	v.ActivationEpoch = Epoch(ssz.UnmarshallUint64(buf[57:65]))

	// Field (4) 'ExitEpoch'
	v.ExitEpoch = Epoch(ssz.UnmarshallUint64(buf[65:73]))

	// Field (5) 'WithdrawableEpoch'
	v.WithdrawableEpoch = Epoch(ssz.UnmarshallUint64(buf[73:81]))

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Validator object
func (v *Validator) SizeSSZ() (size int) {
	size = 81
	return
}

// HashTreeRoot ssz hashes the Validator object
func (v *Validator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Validator object with a hasher
func (v *Validator) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'PublicKey'
	if len(v.PublicKey) != 48 {
		err = ssz.ErrBytesLength
		return
	}
	hh.PutBytes(v.PublicKey)

	// Field (1) 'Slashed'
	hh.PutBool(v.Slashed)

	// Field (2) 'ActivationEligibilityEpoch'
	hh.PutUint64(uint64(v.ActivationEligibilityEpoch))

	// Field (3) 'ActivationEpoch'
	hh.PutUint64(uint64(v.ActivationEpoch))

	// Field (4) 'ExitEpoch'
	hh.PutUint64(uint64(v.ExitEpoch))

	// Field (5) 'WithdrawableEpoch'
	hh.PutUint64(uint64(v.WithdrawableEpoch))

	hh.Merkleize(indx)
	return
}
